use anyhow::{Context, Result};
use argon2::Argon2;
use chacha20poly1305::{
    AeadCore, KeyInit, XChaCha20Poly1305,
    aead::{
        OsRng,
        generic_array::typenum::Unsigned,
        rand_core::RngCore,
        stream::{self},
    },
};
use rand::seq::IndexedRandom;
use std::io::{Read, Seek, Write};

// Argon2id settings.
const ARGON2ID_KEY_LEN: usize = 32;
const ARGON2ID_SALT_LEN: usize = 32;
const ARGON2ID_M_COST: u32 = 512 * 1024;
const ARGON2ID_T_COST: u32 = 6;
const ARGON2ID_P_COST: u32 = 2;
// Passphrase generation.
const PASSPHRASE_WORDS: usize = 5;
const PASSPHRASE_SEPARATOR: &str = "-";
// Encryption handling.
const ENC_PLAIN_CHUNK_SIZE: usize = 1_000_000;
const ENC_OVERHEAD: usize = <XChaCha20Poly1305 as AeadCore>::TagSize::USIZE;
const ENC_NONCE_SIZE: usize = <XChaCha20Poly1305 as AeadCore>::NonceSize::USIZE - 5; // -5 for nonce stream.
const ENC_CRYPT_CHUNK_SIZE: usize = ENC_PLAIN_CHUNK_SIZE + ENC_OVERHEAD;

pub struct Cryptography;

impl Cryptography {
    /// Get a new argon2 instance with program-defined settings.
    fn argon2<'key>() -> Argon2<'key> {
        Argon2::new(
            argon2::Algorithm::default(),
            argon2::Version::default(),
            argon2::Params::new(ARGON2ID_M_COST, ARGON2ID_T_COST, ARGON2ID_P_COST, None)
                .expect("argon2 params const always valid"),
        )
    }

    /// Generate a passphrase from [`eff_wordlist::large::LIST`].
    fn generate_passphrase(len: usize, separator: &str) -> String {
        eff_wordlist::large::LIST
            .choose_multiple(&mut rand::rng(), len)
            .map(|word| word.1)
            .collect::<Vec<_>>()
            .join(separator)
    }

    /// Encrypt `data` by incrementally overwriting it.
    ///
    /// A random human-readable passphrase will be generated during this process;
    /// This passphrase will be ran through a KDF alongside a randomized salt.
    /// The raw passphrase will be returned from this method so it can be used
    /// when decrypting later.
    ///
    /// To decrypt, use [`Cryptography::decrypt`].
    ///
    /// Note that this method will seek `output` to the beginning
    /// at the start and end of the encryption process.
    pub fn encrypt<R: Read + Write + Seek>(data: &mut R) -> Result<String> {
        // Generate passphrase and run it through kdf with a random salt.
        let passphrase = Self::generate_passphrase(PASSPHRASE_WORDS, PASSPHRASE_SEPARATOR);
        let mut salt = [0u8; ARGON2ID_SALT_LEN];
        let mut derived_key = [0u8; ARGON2ID_KEY_LEN];
        OsRng.fill_bytes(&mut salt);
        Self::argon2()
            .hash_password_into(passphrase.as_bytes(), &salt, &mut derived_key)
            .unwrap();

        // Initialise encryptor.
        let mut nonce = [0u8; ENC_NONCE_SIZE];
        OsRng.fill_bytes(&mut nonce);
        let aead = XChaCha20Poly1305::new(&derived_key.into());
        let mut stream_encryptor = stream::EncryptorBE32::from_aead(aead, nonce.as_ref().into());

        // Encrypt file in chunks.
        data.rewind()?;
        data.write_all(&salt)?;
        data.write_all(&nonce)?;
        let mut buffer = [0u8; ENC_PLAIN_CHUNK_SIZE];
        loop {
            let read_count = data.read(&mut buffer)?;
            if read_count == 0 {
                break;
            } else if read_count == ENC_PLAIN_CHUNK_SIZE {
                data.seek(std::io::SeekFrom::Current(-(ENC_PLAIN_CHUNK_SIZE as i64)))?;
                data.write_all(
                    &stream_encryptor
                        .encrypt_next(buffer.as_slice())
                        .context("failed to encrypt buffer segment")?,
                )?;
            } else {
                data.seek(std::io::SeekFrom::Current(-(read_count as i64)))?;
                data.write_all(
                    &stream_encryptor
                        .encrypt_last(&buffer[..read_count])
                        .context("failed to encrypt last buffer segment")?,
                )?;
                break;
            }
        }
        data.rewind()?;
        Ok(passphrase)
    }

    /// Decrypt `data` by incrementally overwriting it.
    ///
    /// This method should only be used with encryption done by [`Cryptography::encrypt`].
    //
    /// The key passed to this method should be the raw key generated by [`Cryptography::encrypt`].
    ///
    /// Note that this method will seek `output` to the beginning
    /// at the start and end of the decryption process.
    pub fn decrypt<R: Read + Write + Seek>(
        passphrase: &str,
        data: &mut R,
    ) -> Result<(), anyhow::Error> {
        data.rewind()?;

        // Read salt + nonce from input file.
        let mut salt = [0u8; ARGON2ID_SALT_LEN];
        data.read_exact(&mut salt)
            .context("could not read salt from input file")?;
        let mut nonce = [0u8; ENC_NONCE_SIZE];
        data.read_exact(&mut nonce)
            .context("could not read nonce from input file")?;

        // Derive key from passphrase.
        let mut derived_key = [0u8; ARGON2ID_KEY_LEN];
        Self::argon2()
            .hash_password_into(passphrase.as_bytes(), &salt, &mut derived_key)
            .unwrap();

        // Initialise decryptor.
        let aead = XChaCha20Poly1305::new(&derived_key.into());
        let mut stream_decryptor = stream::DecryptorBE32::from_aead(aead, nonce.as_ref().into());

        // Decrypt file in chunks.
        let mut buffer = [0u8; ENC_CRYPT_CHUNK_SIZE];
        loop {
            let read_count = data.read(&mut buffer)?;
            if read_count == 0 {
                break;
            } else if read_count == ENC_CRYPT_CHUNK_SIZE {
                data.seek(std::io::SeekFrom::Current(-(ENC_CRYPT_CHUNK_SIZE as i64)))?;
                data.write_all(
                    &stream_decryptor
                        .decrypt_next(buffer.as_slice())
                        .context("failed to decrypt buffer segment")?,
                )?;
            } else {
                data.seek(std::io::SeekFrom::Current(-(read_count as i64)))?;
                data.write_all(
                    &stream_decryptor
                        .decrypt_last(&buffer[..read_count])
                        .context("failed to decrypt last buffer segment")?,
                )?;
                break;
            }
        }
        data.rewind()?;
        Ok(())
    }
}
