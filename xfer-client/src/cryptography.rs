use anyhow::{Context, Result};
use argon2::Argon2;
use chacha20poly1305::{
    AeadCore, KeyInit,
    aead::{Aead, AeadMutInPlace, OsRng, generic_array::typenum::Unsigned, rand_core::RngCore},
};
use rand::seq::IndexedRandom;

// Argon2id settings.
const ARGON2ID_KEY_LEN: usize = 32;
const ARGON2ID_SALT_LEN: usize = 32;
const ARGON2ID_M_COST: u32 = 512 * 1024;
const ARGON2ID_T_COST: u32 = 6;
const ARGON2ID_P_COST: u32 = 2;
// Passphrase generation.
const PASSPHRASE_WORDS: usize = 5;
const PASSPHRASE_SEPARATOR: &str = "-";
// Cryptography implementation.
type CryptoImpl = chacha20poly1305::XChaCha20Poly1305;
type CryptoNonce = chacha20poly1305::XNonce;
const CRYPTO_NONCE_SIZE: usize = <CryptoImpl as AeadCore>::NonceSize::USIZE;

pub struct Cryptography;

impl Cryptography {
    /// Get a new argon2 instance with program-defined settings.
    fn argon2<'key>() -> Argon2<'key> {
        Argon2::new(
            argon2::Algorithm::default(),
            argon2::Version::default(),
            argon2::Params::new(ARGON2ID_M_COST, ARGON2ID_T_COST, ARGON2ID_P_COST, None)
                .expect("argon2 params const always valid"),
        )
    }

    /// Generate a passphrase from [`eff_wordlist::large::LIST`].
    fn generate_passphrase(len: usize, separator: &str) -> String {
        eff_wordlist::large::LIST
            .choose_multiple(&mut rand::rng(), len)
            .map(|word| word.1)
            .collect::<Vec<_>>()
            .join(separator)
    }

    /// Encrypt a byte array in-place.
    ///
    /// A random human-readable passphrase will be generated during this process;
    /// This passphrase will be ran through a KDF alongside a randomized salt.
    ///
    /// This method returns the raw passphrase that was used for encryption,
    /// which can be given to the user to allow them to decrypt the byte array
    /// later.
    ///
    /// To decrypt, use [`Cryptography::decrypt`].
    pub fn encrypt_in_place(bytes: &mut Vec<u8>) -> Result<String> {
        // Create passphrase & derive a key.
        let passphrase = Self::generate_passphrase(PASSPHRASE_WORDS, PASSPHRASE_SEPARATOR);
        let mut salt = [0u8; ARGON2ID_SALT_LEN];
        let mut derived_key = [0u8; ARGON2ID_KEY_LEN];
        OsRng.fill_bytes(&mut salt);
        Self::argon2()
            .hash_password_into(passphrase.as_bytes(), &salt, &mut derived_key)
            .unwrap();
        EncryptedBlob::encrypt_in_place(&derived_key, salt, bytes)?;
        Ok(passphrase)
    }

    /// Decrypt an encrypted byte array.
    ///
    /// This method should only be used with encryption done by [`Cryptography::encrypt_in_place`].
    //
    /// The key passed to this method should be the raw key generated by [`Cryptography::encrypt_in_place`]
    /// as it will be ran through a KDF with the salt from the encrypted byte array.
    pub fn decrypt(bytes: &[u8], key: &str) -> Result<Vec<u8>> {
        let blob = EncryptedBlob::read(bytes)?;
        let mut derived_key = [0u8; ARGON2ID_KEY_LEN];
        Self::argon2()
            .hash_password_into(key.as_bytes(), blob.salt, &mut derived_key)
            .unwrap();
        blob.decrypt(&derived_key)
    }
}

struct EncryptedBlob<'a> {
    salt: &'a [u8; ARGON2ID_SALT_LEN],
    nonce: &'a [u8; CRYPTO_NONCE_SIZE],
    ciphertext: &'a [u8],
}

impl<'a> EncryptedBlob<'a> {
    pub fn read(bytes: &'a [u8]) -> Result<Self> {
        let (salt, rest) = bytes.split_at(ARGON2ID_SALT_LEN);
        let salt = salt.try_into().context("Invalid salt length")?;
        let (nonce, ciphertext) = rest.split_at(CRYPTO_NONCE_SIZE);
        let nonce = nonce.try_into().context("Invalid nonce length")?;
        Ok(Self {
            salt,
            nonce,
            ciphertext,
        })
    }

    pub fn encrypt_in_place<I: IntoIterator<Item = u8>>(
        key: &[u8; ARGON2ID_KEY_LEN],
        salt: I,
        bytes: &mut Vec<u8>,
    ) -> Result<()> {
        let nonce = CryptoImpl::generate_nonce(&mut OsRng);
        let mut cipher = CryptoImpl::new(key.into());
        cipher
            .encrypt_in_place(&nonce, b"", bytes)
            .context("failed to encrypt bytes in place")?;
        bytes.splice(..0, nonce);
        bytes.splice(..0, salt);
        Ok(())
    }

    pub fn decrypt(&self, key: &[u8; ARGON2ID_KEY_LEN]) -> Result<Vec<u8>> {
        let cipher = CryptoImpl::new(key.into());
        cipher
            .decrypt(CryptoNonce::from_slice(self.nonce), self.ciphertext)
            .context("failed to decrypt bytes")
    }
}
