mod wordlist;

use anyhow::{Context, Result};
use argon2::Argon2;
use chacha20poly1305::{
    AeadCore, KeyInit,
    aead::{Aead, AeadMutInPlace, OsRng, generic_array::typenum::Unsigned, rand_core::RngCore},
};
use rand::seq::SliceRandom;
use wordlist::EFF_LARGE_WORDLIST;

type CryptoImpl = chacha20poly1305::XChaCha20Poly1305;
type CryptoNonce = chacha20poly1305::XNonce;
type CryptoNonceSize = <CryptoImpl as AeadCore>::NonceSize;

const PASSPHRASE_WORDS: usize = 5;
const PASSPHRASE_SEPERATOR: &str = "-";
const ARGON2_KEY_LEN: usize = 32;
const ARGON2_SALT_LEN: usize = 32;

#[derive(Debug)]
pub struct Cryptography;

impl Cryptography {
    /// Generate a passphrase from the provided wordlist.
    fn generate_passphrase(
        wordlist: &'static [&'static str],
        words: usize,
        seperator: &str,
    ) -> String {
        let mut word_vec = wordlist.to_vec();
        word_vec.shuffle(&mut rand::rng());
        word_vec[..words].join(seperator)
    }

    /// Create a hash of the given data.
    pub fn hash_data(data: impl AsRef<[u8]>) -> String {
        let mut hasher = blake3::Hasher::new();
        hasher.update(data.as_ref());
        hasher.finalize().to_hex().to_string()
    }

    /// Encrypt a byte array in-place.
    ///
    /// A random human-readable passphrase will be generated during this process
    /// which will be ran through Argon2 alongside a randomized salt.
    ///
    /// This method returns the raw human-readable key that was used for encryption.
    pub fn encrypt_in_place(bytes: &mut Vec<u8>) -> Result<String> {
        // Generate a user-friendly key, a random salt, and run it through argon2.
        let key =
            Self::generate_passphrase(EFF_LARGE_WORDLIST, PASSPHRASE_WORDS, PASSPHRASE_SEPERATOR);
        let mut salt = [0u8; ARGON2_SALT_LEN];
        let mut derived_key = [0u8; ARGON2_KEY_LEN];
        OsRng.fill_bytes(&mut salt);
        Argon2::default()
            .hash_password_into(key.as_bytes(), &salt, &mut derived_key)
            .unwrap();

        // Encrypt bytes using the key and append the salt.
        let nonce = CryptoImpl::generate_nonce(&mut OsRng);
        let mut cipher = CryptoImpl::new(&derived_key.into());
        cipher
            .encrypt_in_place(&nonce, b"", bytes)
            .context("failed to encrypt bytes in place")?;
        bytes.splice(..0, nonce.iter().copied());
        bytes.splice(..0, salt);
        Ok(key)
    }

    /// Decrypt an encrypted byte array.
    ///
    /// This method can only be used with encryption done by [`Cryptography::encrypt_in_place`].
    ///
    /// The key passed to this method should be the raw key generated by [`Cryptography::encrypt_in_place`]
    /// as it will be ran through Argon2 with the salt pulled from the encrypted byte array.
    pub fn decrypt(bytes: &[u8], key: &str) -> Result<Vec<u8>> {
        // Obtain stored values from the encrypted bytes.
        // and recreate the decryption key.
        let (salt, rest) = bytes.split_at(ARGON2_SALT_LEN);
        let (nonce, bytes) = rest.split_at(CryptoNonceSize::to_usize());
        let mut derived_key = [0u8; 32];
        Argon2::default()
            .hash_password_into(key.as_bytes(), &salt, &mut derived_key)
            .unwrap();

        // Decrypt bytes
        let cipher = CryptoImpl::new(&derived_key.into());
        cipher
            .decrypt(CryptoNonce::from_slice(nonce), bytes)
            .context("failed to decrypt bytes")
    }
}
